
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head> <link rel="canonical" href="http://www.mcs.anl.gov/petsc/petsc-current/docs/sphinx_docs/html/manual/performance.html" />
    <meta charset="utf-8" />
    <title>Hints for Performance Tuning &#8212; PETSc 3.14.6 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/katex-math.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"></script>
    <script src="../_static/katex_autorenderer.js"></script>
    <link rel="shortcut icon" href="../_static/PETSc_RGB-logo.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Other PETSc Features" href="other.html" />
    <link rel="prev" title="Profiling" href="profiling.html" /> 
  </head><body>
   <div id="version" align=right><b>petsc-3.14.6 2021-03-30</b></div>
   <div id="bugreport" align=right><a href="mailto:petsc-maint@mcs.anl.gov?subject=Typo or Error in Documentation &body=Please describe the typo or error in the documentation: petsc-3.14.6 v3.14.6 docs/sphinx_docs/html/manual/performance.html "><small>Report Typos and Errors</small></a></div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="other.html" title="Other PETSc Features"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="profiling.html" title="Profiling"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PETSc 3.14.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >PETSc Users Manual</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="additional.html" accesskey="U">Additional Information</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/PETSc-TAO_RGB.svg" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Hints for Performance Tuning</a><ul>
<li><a class="reference internal" href="#maximizing-memory-bandwidth">Maximizing Memory Bandwidth</a><ul>
<li><a class="reference internal" href="#memory-bandwidth-vs-processes">Memory Bandwidth vs. Processes</a></li>
<li><a class="reference internal" href="#non-uniform-memory-access-numa-and-process-placement">Non-Uniform Memory Access (NUMA) and Process Placement</a><ul>
<li><a class="reference internal" href="#additional-process-placement-considerations-and-details">Additional Process Placement Considerations and Details</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#performance-pitfalls-and-advice">Performance Pitfalls and Advice</a><ul>
<li><a class="reference internal" href="#debug-vs-optimized-builds">Debug vs. Optimized Builds</a></li>
<li><a class="reference internal" href="#profiling">Profiling</a></li>
<li><a class="reference internal" href="#aggregation">Aggregation</a></li>
<li><a class="reference internal" href="#memory-allocation-for-sparse-matrix-assembly">Memory Allocation for Sparse Matrix Assembly</a></li>
<li><a class="reference internal" href="#memory-allocation-for-sparse-matrix-factorization">Memory Allocation for Sparse Matrix Factorization</a></li>
<li><a class="reference internal" href="#detecting-memory-allocation-problems">Detecting Memory Allocation Problems</a></li>
<li><a class="reference internal" href="#data-structure-reuse">Data Structure Reuse</a></li>
<li><a class="reference internal" href="#numerical-experiments">Numerical Experiments</a></li>
<li><a class="reference internal" href="#tips-for-efficient-use-of-linear-solvers">Tips for Efficient Use of Linear Solvers</a></li>
<li><a class="reference internal" href="#system-related-problems">System-Related Problems</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="profiling.html"
                        title="previous chapter">Profiling</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="other.html"
                        title="next chapter">Other PETSc Features</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/manual/performance.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="hints-for-performance-tuning">
<span id="ch-performance"></span><h1>Hints for Performance Tuning<a class="headerlink" href="#hints-for-performance-tuning" title="Permalink to this headline">¶</a></h1>
<p>This chapter provides hints on how to get to achieve best performance
with PETSc, particularly on distributed-memory machines with multiple
CPU sockets per node. We focus on machine-related performance
optimization here; algorithmic aspects like preconditioner selection are
not the focus of this section.</p>
<div class="section" id="maximizing-memory-bandwidth">
<h2>Maximizing Memory Bandwidth<a class="headerlink" href="#maximizing-memory-bandwidth" title="Permalink to this headline">¶</a></h2>
<p>Most operations in PETSc deal with large datasets (typically vectors and
sparse matrices) and perform relatively few arithmetic operations for
each byte loaded or stored from global memory. Therefore, the
<em>arithmetic intensity</em> expressed as the ratio of floating point
operations to the number of bytes loaded and stored is usually well
below unity for typical PETSc operations. On the other hand, modern CPUs
are able to execute on the order of 10 floating point operations for
each byte loaded or stored. As a consequence, almost all PETSc
operations are limited by the rate at which data can be loaded or stored
(<em>memory bandwidth limited</em>) rather than by the rate of floating point
operations.</p>
<p>This section discusses ways to maximize the memory bandwidth achieved by
applications based on PETSc. Where appropriate, we include benchmark
results in order to provide quantitative results on typical performance
gains one can achieve through parallelization, both on a single compute
node and across nodes. In particular, we start with the answer to the
common question of why performance generally does not increase 20-fold
with a 20-core CPU.</p>
<div class="section" id="memory-bandwidth-vs-processes">
<span id="subsec-bandwidth-vs-processes"></span><h3>Memory Bandwidth vs. Processes<a class="headerlink" href="#memory-bandwidth-vs-processes" title="Permalink to this headline">¶</a></h3>
<p>Consider the addition of two large vectors, with the result written to a
third vector. Because there are no dependencies across the different
entries of each vector, the operation is embarrasingly parallel.</p>
<div class="figure align-default" id="fig-stream-intel">
<a class="reference internal image-reference" href="../_images/stream-results-intel.png"><img alt="Memory bandwidth obtained on Intel hardware (dual socket except KNL) over the number of processes used. One can get close to peak memory bandwidth with only a few processes." src="../_images/stream-results-intel.png" style="width: 80.0%;" /></a>
<p class="caption"><span class="caption-number">Fig. 8 </span><span class="caption-text">Memory bandwidth obtained on Intel hardware (dual socket except KNL)
over the number of processes used. One can get close to peak memory
bandwidth with only a few processes.</span><a class="headerlink" href="#fig-stream-intel" title="Permalink to this image">¶</a></p>
</div>
<p>As :numref`fig_stream_intel` shows, the performance gains due to
parallelization on different multi- and many-core CPUs quickly
saturates. The reason is that only a fraction of the total number of CPU
cores is required to saturate the memory channels. For example, a
dual-socket system equipped with Haswell 12-core Xeon CPUs achieves more
than 80 percent of achievable peak memory bandwidth with only four
processes per socket (8 total), cf. <a class="reference internal" href="#fig-stream-intel"><span class="std std-numref">Fig. 8</span></a>.
Consequently, running with more than 8 MPI ranks on such a system will
not increase performance substantially. For the same reason, PETSc-based
applications usually do not benefit from hyper-threading.</p>
<p>PETSc provides a simple way to measure memory bandwidth for different
numbers of processes via the target <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">streams</span></code> executed from
<code class="docutils literal notranslate"><span class="pre">$PETSC_DIR</span></code>. The output provides an overview of the possible speedup
one can obtain on the given machine (not necessarily a shared memory
system). For example, the following is the most relevant output obtained
on a dual-socket system equipped with two six-core-CPUs with
hyperthreading:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>np  speedup
1 1.0
2 1.58
3 2.19
4 2.42
5 2.63
6 2.69
...
21 3.82
22 3.49
23 3.79
24 3.71
Estimation of possible speedup of MPI programs based on Streams benchmark.
It appears you have 1 node(s)
</pre></div>
</div>
<p>On this machine, one should expect a speed-up of typical memory
bandwidth-bound PETSc applications of at most 4x when running multiple
MPI ranks on the node. Most of the gains are already obtained when
running with only 4-6 ranks. Because a smaller number of MPI ranks
usually implies better preconditioners and better performance for
smaller problems, the best performance for PETSc applications may be
obtained with fewer ranks than there are physical CPU cores available.</p>
<p>Following the results from the above run of <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">streams</span></code>, we
recommend to use additional nodes instead of placing additional MPI
ranks on the nodes. In particular, weak scaling (i.e. constant load per
process, increasing the number of processes) and strong scaling
(i.e. constant total work, increasing the number of processes) studies
should keep the number of processes per node constant.</p>
</div>
<div class="section" id="non-uniform-memory-access-numa-and-process-placement">
<h3>Non-Uniform Memory Access (NUMA) and Process Placement<a class="headerlink" href="#non-uniform-memory-access-numa-and-process-placement" title="Permalink to this headline">¶</a></h3>
<p>CPUs in nodes with more than one CPU socket are internally connected via
a high-speed fabric, cf. <a class="reference internal" href="#fig-numa"><span class="std std-numref">Fig. 9</span></a>, to enable data
exchange as well as cache coherency. Because main memory on modern
systems is connected via the integrated memory controllers on each CPU,
memory is accessed in a non-uniform way: A process running on one socket
has direct access to the memory channels of the respective CPU, whereas
requests for memory attached to a different CPU socket need to go
through the high-speed fabric. Consequently, best aggregate memory
bandwidth on the node is obtained when the memory controllers on each
CPU are fully saturated. However, full saturation of memory channels is
only possible if the data is distributed across the different memory
channels.</p>
<div class="figure align-default" id="fig-numa">
<a class="reference internal image-reference" href="../_images/numa.png"><img alt="Schematic of a two-socket NUMA system. Processes should be spread across both CPUs to obtain full bandwidth." src="../_images/numa.png" style="width: 90.0%;" /></a>
<p class="caption"><span class="caption-number">Fig. 9 </span><span class="caption-text">Schematic of a two-socket NUMA system. Processes should be spread
across both CPUs to obtain full bandwidth.</span><a class="headerlink" href="#fig-numa" title="Permalink to this image">¶</a></p>
</div>
<p>Data in memory on modern machines is allocated by the operating system
based on a first-touch policy. That is, memory is not allocated at the
point of issuing <code class="docutils literal notranslate"><span class="pre">malloc()</span></code>, but at the point when the respective
memory segment is actually touched (read or write). Upon first-touch,
memory is allocated on the memory channel associated with the respective
CPU the process is running on. Only if all memory on the respective CPU
is already in use (either allocated or as IO cache), memory available
through other sockets is considered.</p>
<p>Maximum memory bandwidth can be achieved by ensuring that processes are
spread over all sockets in the respective node. For example, the
recommended placement of a 8-way parallel run on a four-socket machine
is to assign two processes to each CPU socket. To do so, one needs to
know the enumeration of cores and pass the requested information to
<code class="docutils literal notranslate"><span class="pre">mpirun</span></code>. Consider the hardware topology information returned by
<code class="docutils literal notranslate"><span class="pre">lstopo</span></code> (part of the hwloc package) for the following two-socket
machine, in which each CPU consists of six cores and supports
hyperthreading:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Machine (126GB total)
  NUMANode L#0 (P#0 63GB)
    Package L#0 + L3 L#0 (15MB)
      L2 L#0 (256KB) + L1d L#0 (32KB) + L1i L#0 (32KB) + Core L#0
        PU L#0 (P#0)
        PU L#1 (P#12)
      L2 L#1 (256KB) + L1d L#1 (32KB) + L1i L#1 (32KB) + Core L#1
        PU L#2 (P#1)
        PU L#3 (P#13)
      L2 L#2 (256KB) + L1d L#2 (32KB) + L1i L#2 (32KB) + Core L#2
        PU L#4 (P#2)
        PU L#5 (P#14)
      L2 L#3 (256KB) + L1d L#3 (32KB) + L1i L#3 (32KB) + Core L#3
        PU L#6 (P#3)
        PU L#7 (P#15)
      L2 L#4 (256KB) + L1d L#4 (32KB) + L1i L#4 (32KB) + Core L#4
        PU L#8 (P#4)
        PU L#9 (P#16)
      L2 L#5 (256KB) + L1d L#5 (32KB) + L1i L#5 (32KB) + Core L#5
        PU L#10 (P#5)
        PU L#11 (P#17)
  NUMANode L#1 (P#1 63GB)
    Package L#1 + L3 L#1 (15MB)
      L2 L#6 (256KB) + L1d L#6 (32KB) + L1i L#6 (32KB) + Core L#6
        PU L#12 (P#6)
        PU L#13 (P#18)
      L2 L#7 (256KB) + L1d L#7 (32KB) + L1i L#7 (32KB) + Core L#7
        PU L#14 (P#7)
        PU L#15 (P#19)
      L2 L#8 (256KB) + L1d L#8 (32KB) + L1i L#8 (32KB) + Core L#8
        PU L#16 (P#8)
        PU L#17 (P#20)
      L2 L#9 (256KB) + L1d L#9 (32KB) + L1i L#9 (32KB) + Core L#9
        PU L#18 (P#9)
        PU L#19 (P#21)
      L2 L#10 (256KB) + L1d L#10 (32KB) + L1i L#10 (32KB) + Core L#10
        PU L#20 (P#10)
        PU L#21 (P#22)
      L2 L#11 (256KB) + L1d L#11 (32KB) + L1i L#11 (32KB) + Core L#11
        PU L#22 (P#11)
        PU L#23 (P#23)
</pre></div>
</div>
<p>The relevant physical processor IDs are shown in parentheses prefixed by
<code class="docutils literal notranslate"><span class="pre">P#</span></code>. Here, IDs 0 and 12 share the same physical core and have a
common L2 cache. IDs 0, 12, 1, 13, 2, 14, 3, 15, 4, 16, 5, 17 share the
same socket and have a common L3 cache.</p>
<p>A good placement for a run with six processes is to locate three
processes on the first socket and three processes on the second socket.
Unfortunately, mechanisms for process placement vary across MPI
implementations, so make sure to consult the manual of your MPI
implementation. The following discussion is based on how processor
placement is done with MPICH and OpenMPI, where one needs to pass
<code class="docutils literal notranslate"><span class="pre">--bind-to</span> <span class="pre">core</span> <span class="pre">--map-by</span> <span class="pre">socket</span></code> to <code class="docutils literal notranslate"><span class="pre">mpirun</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$&gt; mpirun -n 6 --bind-to core --map-by socket ./stream
process 0 binding: 100000000000100000000000
process 1 binding: 000000100000000000100000
process 2 binding: 010000000000010000000000
process 3 binding: 000000010000000000010000
process 4 binding: 001000000000001000000000
process 5 binding: 000000001000000000001000
Triad:        45403.1949   Rate (MB/s)
</pre></div>
</div>
<p>In this configuration, process 0 is bound to the first physical core on
the first socket (with IDs 0 and 12), process 1 is bound to the first
core on the second socket (IDs 6 and 18), and similarly for the
remaining processes. The achieved bandwidth of 45 GB/sec is close to the
practical peak of about 50 GB/sec available on the machine. If, however,
all MPI processes are located on the same socket, memory bandwidth drops
significantly:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$&gt; mpirun -n 6 --bind-to core --map-by core ./stream
process 0 binding: 100000000000100000000000
process 1 binding: 010000000000010000000000
process 2 binding: 001000000000001000000000
process 3 binding: 000100000000000100000000
process 4 binding: 000010000000000010000000
process 5 binding: 000001000000000001000000
Triad:        25510.7507   Rate (MB/s)
</pre></div>
</div>
<p>All processes are now mapped to cores on the same socket. As a result,
only the first memory channel is fully saturated at 25.5 GB/sec.</p>
<div class="line-block">
<div class="line">One must not assume that <code class="docutils literal notranslate"><span class="pre">mpirun</span></code> uses good defaults. To
demonstrate, compare the full output of <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">streams</span></code> from
<a class="reference internal" href="#subsec-bandwidth-vs-processes"><span class="std std-ref">Memory Bandwidth vs. Processes</span></a> on the left with
the results on the right obtained by passing
<code class="docutils literal notranslate"><span class="pre">--bind-to</span> <span class="pre">core</span> <span class="pre">--map-by</span> <span class="pre">socket</span></code>:</div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$&gt; make streams
np  speedup
1 1.0
2 1.58
3 2.19
4 2.42
5 2.63
6 2.69
7 2.31
8 2.42
9 2.37
10 2.65
11 2.3
12 2.53
13 2.43
14 2.63
15 2.74
16 2.7
17 3.28
18 3.66
19 3.95
20 3.07
21 3.82
22 3.49
23 3.79
24 3.71
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$&gt; make streams MPI_BINDING=&quot;--bind-to core --map-by socket&quot;
np  speedup
1 1.0
2 1.59
3 2.66
4 3.5
5 3.56
6 4.23
7 3.95
8 4.39
9 4.09
10 4.46
11 4.15
12 4.42
13 3.71
14 3.83
15 4.08
16 4.22
17 4.18
18 4.31
19 4.22
20 4.28
21 4.25
22 4.23
23 4.28
24 4.22
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">For the non-optimized version on the left, the speedup obtained when
using any number of processes between 3 and 13 is essentially constant
up to fluctuations, indicating that all processes were by default
executed on the same socket. Only with 14 or more processes, the
speedup number increases again. In contrast, the results of
<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">streams</span></code> with proper processor placement shown on the right
resulted in slightly higher overall parallel speedup (identical
baselines), in smaller performance fluctuations, and more than 90
percent of peak bandwidth with only six processes.</div>
</div>
<p>Machines with job submission systems such as SLURM usually provide
similar mechanisms for processor placements through options specified in
job submission scripts. Please consult the respective manuals.</p>
<div class="section" id="additional-process-placement-considerations-and-details">
<h4>Additional Process Placement Considerations and Details<a class="headerlink" href="#additional-process-placement-considerations-and-details" title="Permalink to this headline">¶</a></h4>
<p>For a typical, memory bandwidth-limited PETSc application, the primary
consideration in placing MPI processes is ensuring that processes are
evenly distributed among sockets, and hence using all available memory
channels. Increasingly complex processor designs and cache hierarchies,
however, mean that performance may also be sensitive to how processes
are bound to the resources within each socket. Performance on the two
processor machine in the preceding example may be relatively insensitive
to such placement decisions, because one L3 cache is shared by all cores
within a NUMA domain, and each core has its own L2 and L1 caches.
However, processors that are less “flat”, with more complex hierarchies,
may be more sensitive. In many AMD Opterons or the second-generation
“Knights Landing” Intel Xeon Phi, for instance, L2 caches are shared
between two cores. On these processors, placing consecutive MPI ranks on
cores that share the same L2 cache may benefit performance if the two
ranks communicate frequently with each other, because the latency
between cores sharing an L2 cache may be roughly half that of two cores
not sharing one. There may be benefit, however, in placing consecutive
ranks on cores that do not share an L2 cache, because (if there are
fewer MPI ranks than cores) this increases the total L2 cache capacity
and bandwidth available to the application. There is a trade-off to be
considered between placing processes close together (in terms of shared
resources) to optimize for efficient communication and synchronization
vs. farther apart to maximize available resources (memory channels,
caches, I/O channels, etc.), and the best strategy will depend on the
application and the software and hardware stack.</p>
<p>Different process placement strategies can affect performance at least
as much as some commonly explored settings, such as compiler
optimization levels. Unfortunately, exploration of this space is
complicated by two factors: First, processor and core numberings may be
completely arbitrary, changing with BIOS version, etc., and second—as
already noted—there is no standard mechanism used by MPI implementations
(or job schedulers) to specify process affinity. To overcome the first
issue, we recommend using the <code class="docutils literal notranslate"><span class="pre">lstopo</span></code> utility of the Portable
Hardware Locality (<code class="docutils literal notranslate"><span class="pre">hwloc</span></code>) software package (which can be installed
by configuring PETSc with <code class="docutils literal notranslate"><span class="pre">–download-hwloc</span></code>) to understand the
processor topology of your machine. We cannot fully address the second
issue—consult the documenation for your MPI implementation and/or job
scheduler—but we offer some general observations on understanding
placement options:</p>
<ul class="simple">
<li><p>An MPI implementation may support a notion of <em>domains</em> in which a
process may be pinned. A domain may simply correspond to a single
core; however, the MPI implementation may allow a deal of flexibility
in specifying domains that encompass multiple cores, span sockets,
etc. Some implementations, such as Intel MPI, provide means to
specify whether domains should be “compact”—composed of cores sharing
resources such as caches—or “scatter”-ed, with little resource
sharing (possibly even spanning sockets).</p></li>
<li><p>Separate from the specification of domains, MPI implementations often
support different <em>orderings</em> in which MPI ranks should be bound to
these domains. Intel MPI, for instance, supports “compact” ordering
to place consecutive ranks close in terms of shared resources,
“scatter” to place them far apart, and “bunch” to map proportionally
to sockets while placing ranks as close together as possible within
the sockets.</p></li>
<li><p>An MPI implemenation that supports process pinning should offer some
way to view the rank assignments. Use this output in conjunction with
the topology obtained via <code class="docutils literal notranslate"><span class="pre">lstopo</span></code> or a similar tool to determine
if the placements correspond to something you believe is reasonable
for your application. Do not assume that the MPI implementation is
doing something sensible by default!</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="performance-pitfalls-and-advice">
<h2>Performance Pitfalls and Advice<a class="headerlink" href="#performance-pitfalls-and-advice" title="Permalink to this headline">¶</a></h2>
<p>This section looks into a potpourri of performance pitfalls encountered
by users in the past. Many of these pitfalls require a deeper
understanding of the system and experience to detect. The purpose of
this section is to summarize and share our experience so that these
pitfalls can be avoided in the future.</p>
<div class="section" id="debug-vs-optimized-builds">
<h3>Debug vs. Optimized Builds<a class="headerlink" href="#debug-vs-optimized-builds" title="Permalink to this headline">¶</a></h3>
<p>PETSc’s <code class="docutils literal notranslate"><span class="pre">./configure</span></code> defaults to building PETSc with debug mode
enabled. Any code development should be done in this mode, because it
provides handy debugging facilities such as accurate stack traces,
memory leak checks, or memory corruption checks. Note that PETSc has no
reliable way of knowing whether a particular run is a production or
debug run. In the case that a user requests profiling information via
<code class="docutils literal notranslate"><span class="pre">-log_view</span></code>, a debug build of PETSc issues the following warning:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>##########################################################
#                                                        #
#                          WARNING!!!                    #
#                                                        #
#   This code was compiled with a debugging option,      #
#   To get timing results run ./configure                #
#   using --with-debugging=no, the performance will      #
#   be generally two or three times faster.              #
#                                                        #
##########################################################
</pre></div>
</div>
<p>Conversely, one way of checking whether a particular build of PETSc has
debugging enabled is to inspect the output of <code class="docutils literal notranslate"><span class="pre">-log_view</span></code>.</p>
<p>Debug mode will generally be most useful for code development if
appropriate compiler options are set to faciliate debugging. The
compiler should be instructed to generate binaries with debug symbols
(command line option <code class="docutils literal notranslate"><span class="pre">-g</span></code> for most compilers), and the optimization
level chosen should either completely disable optimizations (<code class="docutils literal notranslate"><span class="pre">-O0</span></code> for
most compilers) or enable only optimizations that do not interfere with
debugging (GCC, for instance, supports a <code class="docutils literal notranslate"><span class="pre">-Og</span></code> optimization level that
does this).</p>
<p>Only once the new code is thoroughly tested and ready for production,
one should disable debugging facilities by passing
<code class="docutils literal notranslate"><span class="pre">--with-debugging=no</span></code> to</p>
<p><code class="docutils literal notranslate"><span class="pre">./configure</span></code>. One should also ensure that an appropriate compiler
optimization level is set. Note that some compilers (e.g., Intel)
default to fairly comprehensive optimization levels, while others (e.g.,
GCC) default to no optimization at all. The best optimization flags will
depend on your code, the compiler, and the target architecture, but we
offer a few guidelines for finding those that will offer the best
performance:</p>
<ul class="simple">
<li><p>Most compilers have a number of optimization levels (with level n
usually specified via <code class="docutils literal notranslate"><span class="pre">-On</span></code>) that provide a quick way to enable
sets of several optimization flags. We suggest trying the higher
optimization levels (the highest level is not guaranteed to produce
the fastest executable, so some experimentation may be merited). With
most recent processors now supporting some form of SIMD or vector
instructions, it is important to choose a level that enables the
compiler’s auto-vectorizer; many compilers do not enable
auto-vectorization at lower optimization levels (e.g., GCC does not
enable it below <code class="docutils literal notranslate"><span class="pre">-O3</span></code> and the Intel compiler does not enable it
below <code class="docutils literal notranslate"><span class="pre">-O2</span></code>).</p></li>
<li><p>For processors supporting newer vector instruction sets, such as
Intel AVX2 and AVX-512, it is also important to direct the compiler
to generate code that targets these processors (.e.g., <code class="docutils literal notranslate"><span class="pre">-march=knl</span></code>
to generate AVX-512 binaries targeting the Intel “Knights Landing”
Xeon Phi processor); otherwise, the executables built will not
utilize the newer instructions sets and will not take advantage of
the vector processing units.</p></li>
<li><p>Beyond choosing the optimization levels, some value-unsafe
optimizations (such as using reciprocals of values instead of
dividing by those values, or allowing re-association of operands in a
series of calculations) for floating point calculations may yield
significant performance gains. Compilers often provide flags (e.g.,
<code class="docutils literal notranslate"><span class="pre">-ffast-math</span></code> in GCC) to enable a set of these optimizations, and
they may be turned on when using options for very aggressive
optimization (<code class="docutils literal notranslate"><span class="pre">-fast</span></code> or <code class="docutils literal notranslate"><span class="pre">-Ofast</span></code> in many compilers). These are
worth exploring to maximize performance, but, if employed, it
important to verify that these do not cause erroneous results with
your code, since calculations may violate the IEEE standard for
floating-point arithmetic.</p></li>
</ul>
</div>
<div class="section" id="profiling">
<h3>Profiling<a class="headerlink" href="#profiling" title="Permalink to this headline">¶</a></h3>
<p>Users should not spend time optimizing a code until after having
determined where it spends the bulk of its time on realistically sized
problems. As discussed in detail in <a class="reference internal" href="profiling.html#ch-profiling"><span class="std std-ref">Profiling</span></a>, the
PETSc routines automatically log performance data if certain runtime
options are specified.</p>
<p>To obtain a summary of where and how much time is spent in different
sections of the code, use one of the following options:</p>
<ul class="simple">
<li><p>Run the code with the option <code class="docutils literal notranslate"><span class="pre">-log_view</span></code> to print a performance
summary for various phases of the code.</p></li>
<li><p>Run the code with the option <code class="docutils literal notranslate"><span class="pre">-log_mpe</span></code> <code class="docutils literal notranslate"><span class="pre">[logfilename]</span></code>, which
creates a logfile of events suitable for viewing with Jumpshot (part
of MPICH).</p></li>
</ul>
<p>Then, focus on the sections where most of the time is spent. If you
provided your own callback routines, e.g. for residual evaluations,
search the profiling output for routines such as <code class="docutils literal notranslate"><span class="pre">SNESFunctionEval</span></code> or
<code class="docutils literal notranslate"><span class="pre">SNESJacobianEval</span></code>. If their relative time is significant (say, more
than 30 percent), consider optimizing these routines first. Generic
instructions on how to optimize your callback functions are difficult;
you may start by reading performance optimization guides for your
system’s hardware.</p>
</div>
<div class="section" id="aggregation">
<h3>Aggregation<a class="headerlink" href="#aggregation" title="Permalink to this headline">¶</a></h3>
<p>Performing operations on chunks of data rather than a single element at
a time can significantly enhance performance because of cache reuse or
lower data motion. Typical examples are:</p>
<ul class="simple">
<li><p>Insert several (many) elements of a matrix or vector at once, rather
than looping and inserting a single value at a time. In order to
access elements in of vector repeatedly, employ <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecGetArray.html#VecGetArray">VecGetArray</a>()</span></code> to
allow direct manipulation of the vector elements.</p></li>
<li><p>When possible, use <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecMDot.html#VecMDot">VecMDot</a>()</span></code> rather than a series of calls to
<code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecDot.html#VecDot">VecDot</a>()</span></code>.</p></li>
<li><p>If you require a sequence of matrix-vector products with the same
matrix, consider packing your vectors into a single matrix and use
matrix-matrix multiplications.</p></li>
<li><p>Users should employ a reasonable number of <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscMalloc.html#PetscMalloc">PetscMalloc</a>()</span></code> calls in
their codes. Hundreds or thousands of memory allocations may be
appropriate; however, if tens of thousands are being used, then
reducing the number of <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscMalloc.html#PetscMalloc">PetscMalloc</a>()</span></code> calls may be warranted. For
example, reusing space or allocating large chunks and dividing it
into pieces can produce a significant savings in allocation overhead.
<a class="reference internal" href="#sec-dsreuse"><span class="std std-ref">Data Structure Reuse</span></a> gives details.</p></li>
</ul>
<p>Aggressive aggregation of data may result in inflexible datastructures
and code that is hard to maintain. We advise users to keep these
competing goals in mind and not blindly optimize for performance only.</p>
</div>
<div class="section" id="memory-allocation-for-sparse-matrix-assembly">
<span id="sec-perf-memory"></span><h3>Memory Allocation for Sparse Matrix Assembly<a class="headerlink" href="#memory-allocation-for-sparse-matrix-assembly" title="Permalink to this headline">¶</a></h3>
<p>Since the process of dynamic memory allocation for sparse matrices is
inherently very expensive, accurate preallocation of memory is crucial
for efficient sparse matrix assembly. One should use the matrix creation
routines for particular data structures, such as <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatCreateSeqAIJ.html#MatCreateSeqAIJ">MatCreateSeqAIJ</a>()</span></code>
and <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatCreateAIJ.html#MatCreateAIJ">MatCreateAIJ</a>()</span></code> for compressed, sparse row formats, instead of
the generic <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatCreate.html#MatCreate">MatCreate</a>()</span></code> routine. For problems with multiple degrees
of freedom per node, the block, compressed, sparse row formats, created
by <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatCreateSeqBAIJ.html#MatCreateSeqBAIJ">MatCreateSeqBAIJ</a>()</span></code> and <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatCreateBAIJ.html#MatCreateBAIJ">MatCreateBAIJ</a>()</span></code>, can significantly
enhance performance. <a class="reference internal" href="mat.html#sec-matsparse"><span class="std std-ref">Sparse Matrices</span></a> includes
extensive details and examples regarding preallocation.</p>
</div>
<div class="section" id="memory-allocation-for-sparse-matrix-factorization">
<span id="sec-symbolfactor"></span><h3>Memory Allocation for Sparse Matrix Factorization<a class="headerlink" href="#memory-allocation-for-sparse-matrix-factorization" title="Permalink to this headline">¶</a></h3>
<p>When symbolically factoring an AIJ matrix, PETSc has to guess how much
fill there will be. Careful use of the fill parameter in the
<code class="docutils literal notranslate"><span class="pre">MatILUInfo</span></code> structure when calling <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatLUFactorSymbolic.html#MatLUFactorSymbolic">MatLUFactorSymbolic</a>()</span></code> or
<code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatILUFactorSymbolic.html#MatILUFactorSymbolic">MatILUFactorSymbolic</a>()</span></code> can reduce greatly the number of mallocs and
copies required, and thus greatly improve the performance of the
factorization. One way to determine a good value for the fill parameter
is to run a program with the option <code class="docutils literal notranslate"><span class="pre">-info</span></code>. The symbolic
factorization phase will then print information such as</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Info:MatILUFactorSymbolic_AIJ:Realloc 12 Fill ratio:given 1 needed 2.16423
</pre></div>
</div>
<p>This indicates that the user should have used a fill estimate factor of
about 2.17 (instead of 1) to prevent the 12 required mallocs and copies.
The command line option</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-pc_ilu_fill 2.17
</pre></div>
</div>
<p>will cause PETSc to preallocate the correct amount of space for
incomplete (ILU) factorization. The corresponding option for direct (LU)
factorization is <code class="docutils literal notranslate"><span class="pre">-pc_factor_fill</span> <span class="pre">&lt;fill_amount&gt;</span></code>.</p>
</div>
<div class="section" id="detecting-memory-allocation-problems">
<span id="detecting-memory-problems"></span><h3>Detecting Memory Allocation Problems<a class="headerlink" href="#detecting-memory-allocation-problems" title="Permalink to this headline">¶</a></h3>
<p>PETSc provides a number of tools to aid in detection of problems with
memory allocation, including leaks and use of uninitialized space. We
briefly describe these below.</p>
<ul class="simple">
<li><p>The PETSc memory allocation (which collects statistics and performs
error checking), is employed by default for codes compiled in a
debug-mode (configured with <code class="docutils literal notranslate"><span class="pre">--with-debugging=1</span></code>). PETSc memory
allocation can be activated for optimized-mode (configured with
<code class="docutils literal notranslate"><span class="pre">--with-debugging=0</span></code>) using the option <code class="docutils literal notranslate"><span class="pre">-malloc</span></code>. The option
<code class="docutils literal notranslate"><span class="pre">-malloc=0</span></code> forces the use of conventional memory allocation when
debugging is enabled. When running timing tests, one should build
libraries in optimized mode.</p></li>
<li><p>When the PETSc memory allocation routines are used, the option
<code class="docutils literal notranslate"><span class="pre">-malloc_dump</span></code> will print a list of unfreed memory at the
conclusion of a program. If all memory has been freed, only a message
stating the maximum allocated space will be printed. However, if some
memory remains unfreed, this information will be printed. Note that
the option <code class="docutils literal notranslate"><span class="pre">-malloc_dump</span></code> merely activates a call to
<code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscMallocDump.html#PetscMallocDump">PetscMallocDump</a>()</span></code> during <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscFinalize.html#PetscFinalize">PetscFinalize</a>()</span></code> the user can also
call <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscMallocDump.html#PetscMallocDump">PetscMallocDump</a>()</span></code> elsewhere in a program.</p></li>
<li><p>Another useful option for use with PETSc memory allocation routines
is <code class="docutils literal notranslate"><span class="pre">-malloc_view</span></code>, which activates logging of all calls to malloc
and reports memory usage, including all Fortran arrays. This option
provides a more complete picture than <code class="docutils literal notranslate"><span class="pre">-malloc_dump</span></code> for codes that
employ Fortran with hardwired arrays. The option <code class="docutils literal notranslate"><span class="pre">-malloc_view</span></code>
activates logging by calling <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscMallocViewSet.html#PetscMallocViewSet">PetscMallocViewSet</a>()</span></code> in
<code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscInitialize.html#PetscInitialize">PetscInitialize</a>()</span></code> and then prints the log by calling
<code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscMallocView.html#PetscMallocView">PetscMallocView</a>()</span></code> in <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscFinalize.html#PetscFinalize">PetscFinalize</a>()</span></code>. The user can also call
these routines elsewhere in a program. When finer granularity is
desired, the user should call <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscMallocGetCurrentUsage.html#PetscMallocGetCurrentUsage">PetscMallocGetCurrentUsage</a>()</span></code> and
<code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscMallocGetMaximumUsage.html#PetscMallocGetMaximumUsage">PetscMallocGetMaximumUsage</a>()</span></code> for memory allocated by PETSc, or
<code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscMemoryGetCurrentUsage.html#PetscMemoryGetCurrentUsage">PetscMemoryGetCurrentUsage</a>()</span></code> and <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscMemoryGetMaximumUsage.html#PetscMemoryGetMaximumUsage">PetscMemoryGetMaximumUsage</a>()</span></code>
for the total memory used by the program. Note that
<code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscMemorySetGetMaximumUsage.html#PetscMemorySetGetMaximumUsage">PetscMemorySetGetMaximumUsage</a>()</span></code> must be called before
<code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscMemoryGetMaximumUsage.html#PetscMemoryGetMaximumUsage">PetscMemoryGetMaximumUsage</a>()</span></code> (typically at the beginning of the
program).</p></li>
</ul>
</div>
<div class="section" id="data-structure-reuse">
<span id="sec-dsreuse"></span><h3>Data Structure Reuse<a class="headerlink" href="#data-structure-reuse" title="Permalink to this headline">¶</a></h3>
<p>Data structures should be reused whenever possible. For example, if a
code often creates new matrices or vectors, there often may be a way to
reuse some of them. Very significant performance improvements can be
achieved by reusing matrix data structures with the same nonzero
pattern. If a code creates thousands of matrix or vector objects,
performance will be degraded. For example, when solving a nonlinear
problem or timestepping, reusing the matrices and their nonzero
structure for many steps when appropriate can make the code run
significantly faster.</p>
<p>A simple technique for saving work vectors, matrices, etc. is employing
a user-defined context. In C and C++ such a context is merely a
structure in which various objects can be stashed; in Fortran a user
context can be an integer array that contains both parameters and
pointers to PETSc objects. See
<a class="reference external" href="https://www.mcs.anl.gov/petsc/petsc-current/src/snes/tutorials/ex5.c.html">SNES Tutorial ex5</a>
and
<a class="reference external" href="https://www.mcs.anl.gov/petsc/petsc-current/src/snes/tutorials/ex5f.F90.html">SNES Tutorial ex5f</a>
for examples of user-defined application contexts in C and Fortran,
respectively.</p>
</div>
<div class="section" id="numerical-experiments">
<h3>Numerical Experiments<a class="headerlink" href="#numerical-experiments" title="Permalink to this headline">¶</a></h3>
<p>PETSc users should run a variety of tests. For example, there are a
large number of options for the linear and nonlinear equation solvers in
PETSc, and different choices can make a <em>very</em> big difference in
convergence rates and execution times. PETSc employs defaults that are
generally reasonable for a wide range of problems, but clearly these
defaults cannot be best for all cases. Users should experiment with many
combinations to determine what is best for a given problem and customize
the solvers accordingly.</p>
<ul class="simple">
<li><p>Use the options <code class="docutils literal notranslate"><span class="pre">-snes_view</span></code>, <code class="docutils literal notranslate"><span class="pre">-ksp_view</span></code>, etc. (or the routines
<code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPView.html#KSPView">KSPView</a>()</span></code>, <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/SNES/SNESView.html#SNESView">SNESView</a>()</span></code>, etc.) to view the options that have
been used for a particular solver.</p></li>
<li><p>Run the code with the option <code class="docutils literal notranslate"><span class="pre">-help</span></code> for a list of the available
runtime commands.</p></li>
<li><p>Use the option <code class="docutils literal notranslate"><span class="pre">-info</span></code> to print details about the solvers’
operation.</p></li>
<li><p>Use the PETSc monitoring discussed in <a class="reference internal" href="profiling.html#ch-profiling"><span class="std std-ref">Profiling</span></a>
to evaluate the performance of various numerical methods.</p></li>
</ul>
</div>
<div class="section" id="tips-for-efficient-use-of-linear-solvers">
<span id="sec-slestips"></span><h3>Tips for Efficient Use of Linear Solvers<a class="headerlink" href="#tips-for-efficient-use-of-linear-solvers" title="Permalink to this headline">¶</a></h3>
<p>As discussed in <a class="reference internal" href="ksp.html#chapter-ksp"><span class="std std-ref">KSP: Linear System Solvers</span></a>, the default linear
solvers are</p>
<ul>
<li><div class="line-block">
<div class="line">uniprocess: GMRES(30) with ILU(0) preconditioning</div>
</div>
</li>
<li><div class="line-block">
<div class="line">multiprocess: GMRES(30) with block Jacobi preconditioning, where
there is 1 block per process, and each block is solved with ILU(0)</div>
</div>
</li>
</ul>
<p>One should experiment to determine alternatives that may be better for
various applications. Recall that one can specify the <code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSP.html#KSP">KSP</a></span></code> methods
and preconditioners at runtime via the options:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-ksp_type &lt;ksp_name&gt; -pc_type &lt;pc_name&gt;
</pre></div>
</div>
<p>One can also specify a variety of runtime customizations for the
solvers, as discussed throughout the manual.</p>
<p>In particular, note that the default restart parameter for GMRES is 30,
which may be too small for some large-scale problems. One can alter this
parameter with the option <code class="docutils literal notranslate"><span class="pre">-ksp_gmres_restar</span> <span class="pre">&lt;restart&gt;</span></code> or by calling
<code class="docutils literal notranslate"><span class="pre"><a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/KSP/KSPGMRESSetRestart.html#KSPGMRESSetRestart">KSPGMRESSetRestart</a>()</span></code>. <a class="reference internal" href="ksp.html#sec-ksp"><span class="std std-ref">Krylov Methods</span></a> gives
information on setting alternative GMRES orthogonalization routines,
which may provide much better parallel performance.</p>
<p>For elliptic problems one often obtains good performance and scalability
with multigrid solvers. Consult <a class="reference internal" href="ksp.html#sec-amg"><span class="std std-ref">Algebraic Multigrid (AMG) Preconditioners</span></a> for
available options. Our experience is that GAMG works particularly well
for elasticity problems, whereas hypre does well for scalar problems.</p>
</div>
<div class="section" id="system-related-problems">
<h3>System-Related Problems<a class="headerlink" href="#system-related-problems" title="Permalink to this headline">¶</a></h3>
<p>The performance of a code can be affected by a variety of factors,
including the cache behavior, other users on the machine, etc. Below we
briefly describe some common problems and possibilities for overcoming
them.</p>
<ul class="simple">
<li><p><strong>Problem too large for physical memory size</strong>: When timing a
program, one should always leave at least a ten percent margin
between the total memory a process is using and the physical size of
the machine’s memory. One way to estimate the amount of memory used
by given process is with the UNIX <code class="docutils literal notranslate"><span class="pre">getrusage</span></code> system routine. Also,
the PETSc option <code class="docutils literal notranslate"><span class="pre">-log_view</span></code> prints the amount of memory used by
the basic PETSc objects, thus providing a lower bound on the memory
used. Another useful option is <code class="docutils literal notranslate"><span class="pre">-malloc_view</span></code> which reports all
memory, including any Fortran arrays in an application code.</p></li>
<li><p><strong>Effects of other users</strong>: If other users are running jobs on the
same physical processor nodes on which a program is being profiled,
the timing results are essentially meaningless.</p></li>
<li><p><strong>Overhead of timing routines on certain machines</strong>: On certain
machines, even calling the system clock in order to time routines is
slow; this skews all of the flop rates and timing results. The file
<code class="docutils literal notranslate"><span class="pre">$PETSC_DIR/src/benchmarks/<a href="https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscTime.html#PetscTime">PetscTime</a>.c</span></code> (<a class="reference external" href="https://www.mcs.anl.gov/petsc/petsc-current/src/benchmarks/PetscTime.c.html">source</a>)
contains a simple test problem that will approximate the amount of
time required to get the current time in a running program. On good
systems it will on the order of <span class="math">\(10^{-6}\)</span> seconds or less.</p></li>
<li><p><strong>Problem too large for good cache performance</strong>: Certain machines
with lower memory bandwidths (slow memory access) attempt to
compensate by having a very large cache. Thus, if a significant
portion of an application fits within the cache, the program will
achieve very good performance; if the code is too large, the
performance can degrade markedly. To analyze whether this situation
affects a particular code, one can try plotting the total flop rate
as a function of problem size. If the flop rate decreases rapidly at
some point, then the problem may likely be too large for the cache
size.</p></li>
<li><p><strong>Inconsistent timings</strong>: Inconsistent timings are likely due to
other users on the machine, thrashing (using more virtual memory than
available physical memory), or paging in of the initial executable.
<a class="reference internal" href="profiling.html#sec-profaccuracy"><span class="std std-ref">Accurate Profiling and Paging Overheads</span></a> provides information on
overcoming paging overhead when profiling a code. We have found on
all systems that if you follow all the advise above your timings will
be consistent within a variation of less than five percent.</p></li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="other.html" title="Other PETSc Features"
             >next</a> |</li>
        <li class="right" >
          <a href="profiling.html" title="Profiling"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PETSc 3.14.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >PETSc Users Manual</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="additional.html" >Additional Information</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 1991-2021, UChicago Argonne, LLC and the PETSc Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>
  </body>
</html>